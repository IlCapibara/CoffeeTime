package com.gc.coffeetime.service;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.gc.coffeetime.model.PomInfo;
import com.gc.coffeetime.model.ProjectVersions;

public class RepositoryServiceImpl implements RepositoryService {

	@Override
	public PomInfo readPomFile(File pomFile) {
		try {
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(pomFile);
			doc.getDocumentElement().normalize();

			Element rootElement = doc.getDocumentElement();

			String groupId = getTagValue("groupId", rootElement);
			String artifactId = getTagValue("artifactId", rootElement);
			String version = getTagValue("version", rootElement);

			return new PomInfo(groupId, artifactId, version);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	private static String getTagValue(String tag, Element element) {
		NodeList nodeList = element.getElementsByTagName(tag);
		if (nodeList != null && nodeList.getLength() > 0) {
			return nodeList.item(0).getTextContent();
		}
		return "";
	}


	@Override
	public List<File> findAllPomFiles(String startDir) {
		List<File> pomFiles = new ArrayList<>();

		try (Stream<Path> paths = Files.walk(Paths.get(startDir), FileVisitOption.FOLLOW_LINKS)) {
			pomFiles = paths
					.filter(Files::isRegularFile)
					// Excluding target directories
					.filter(path -> !path.toString().contains(File.separator + "target" + File.separator))
					.filter(path -> path.getFileName().toString().equals("pom.xml"))
					.map(Path::toFile)                    
					.collect(Collectors.toList());
		} catch (IOException e) {
			e.printStackTrace();
		}

		return pomFiles;
	}

	public List<PomInfo> getLocalVersions(List<File> pomFiles) {    	
		List<PomInfo> pomListWithVersion = new ArrayList<>();

		for(File pomFile : pomFiles) {
			PomInfo info = readPomFile(pomFile);
			pomListWithVersion.add(info);
		}

		return pomListWithVersion;
	}

	@Override
	public void updatePomFile(File pomFile, List<ProjectVersions> latestVersions) {
	    try {
	        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
	        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
	        Document doc = dBuilder.parse(pomFile);
	        doc.getDocumentElement().normalize();

	        // Find <dependencies> node
	        NodeList dependenciesNodes = doc.getElementsByTagName("dependencies");
	        
	        // Cycle through <dependencies>
	        for (int j = 0; j < dependenciesNodes.getLength(); j++) {
	            Node dependenciesNode = dependenciesNodes.item(j);
	            
	            // Find <dependency> node in <dependencies>
	            NodeList dependencies = ((Element) dependenciesNode).getElementsByTagName("dependency");

	            for (int i = 0; i < dependencies.getLength(); i++) {
	                Node dependency = dependencies.item(i);

	                if (dependency.getNodeType() == Node.ELEMENT_NODE) {
	                    Element depElement = (Element) dependency;
	                    String groupId = getTagValue("groupId", depElement);
	                    String artifactId = getTagValue("artifactId", depElement);
	                    String currentVersion = getTagValue("version", depElement);

	                    // Find most recent in local versions
	                    String latestVersion = getLatestVersion(groupId, artifactId, latestVersions);
	                    if (latestVersion != null && !latestVersion.equals(currentVersion)) {
	                        // Update dependency version
	                        Node versionNode = depElement.getElementsByTagName("version").item(0);
	                        versionNode.setTextContent(latestVersion);
	                        System.out.println("Updated " + groupId + ":" + artifactId + " to version " + latestVersion);
	                    }
	                }
	            }
	        }

	        // Write file
	        saveDocumentToFile(doc, pomFile);

	    } catch (Exception e) {
	        e.printStackTrace();
	    }
	}


	private String getLatestVersion(String groupId, String artifactId, List<ProjectVersions> latestVersions) {
		for (ProjectVersions version : latestVersions) {
			if (version.getGroupId().equals(groupId) && version.getArtifactId().equals(artifactId)) {
				return version.getVersion();
			}
		}
		return null;
	}

	private void saveDocumentToFile(Document doc, File file) {
		try {
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			Transformer transformer = transformerFactory.newTransformer();
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(file);
			transformer.transform(source, result);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
