package com.gc.coffeetime.service;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;


import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

// Constructor
	public RepositoryServiceImpl() {
		printBanner();
	}

	// Banner
	@Override
	public void printBanner() {
		try {
			String asciiArt = FigletFont.convertOneLine("CoffeeTime");
			System.out.println(asciiArt);
		} catch (Exception e) {
			e.printStackTrace();
		}

		System.out.println("==========================================================");
		System.out.println("This program scans all pom.xml files in the selected      ");
		System.out.println("folder, finds the latest local versions for dependencies, ");
		System.out.println("and updates the pom.xml files accordingly.                ");
		System.out.println("==========================================================\n");

	}

	@Override
	public ProjectVersions readPomFile(File pomFile) {
		try {
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(pomFile);
			doc.getDocumentElement().normalize();

			Element rootElement = doc.getDocumentElement();

			String groupId = getTagValue("groupId", rootElement);
			String artifactId = getTagValue("artifactId", rootElement);
			String version = getTagValue("version", rootElement);

			return new ProjectVersions(groupId, artifactId, version);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	private static String getTagValue(String tag, Element element) {
		NodeList nodeList = element.getElementsByTagName(tag);
		if (nodeList != null && nodeList.getLength() > 0) {
			return nodeList.item(0).getTextContent();
		}
		return "";
	}


	@Override
	public List<File> findAllPomFiles(String startDir) {
		List<File> pomFiles = new ArrayList<>();

		try (Stream<Path> paths = Files.walk(Paths.get(startDir), FileVisitOption.FOLLOW_LINKS)) {
			pomFiles = paths
					.filter(Files::isRegularFile)
					// Excluding target directories
					.filter(path -> !path.toString().contains(File.separator + "target" + File.separator))
					.filter(path -> path.getFileName().toString().equals("pom.xml"))
					.map(Path::toFile)                    
					.collect(Collectors.toList());
		} catch (IOException e) {
			e.printStackTrace();
		}

		return pomFiles;
	}

	public List<ProjectVersions> getLocalVersions(List<File> pomFiles) {    	
		List<ProjectVersions> pomListWithVersion = new ArrayList<>();

		for(File pomFile : pomFiles) {
			ProjectVersions info = readPomFile(pomFile);
			pomListWithVersion.add(info);
		}

		return pomListWithVersion;
	}

	import org.jsoup.Jsoup;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.gc.coffeetime.model.ProjectVersions;
import com.github.lalyos.jfiglet.FigletFont;

	public void updatePomFile(File pomFile, List<ProjectVersions> latestVersions) {
	    try {
	        // Carica il file pom.xml utilizzando Jsoup
	        Document doc = Jsoup.parse(pomFile, "UTF-8", "", org.jsoup.parser.Parser.xmlParser());

	        // Trova tutti i nodi <dependency>
	        for (Element dependency : doc.select("dependency")) {
	            String groupId = dependency.selectFirst("groupId").text();
	            String artifactId = dependency.selectFirst("artifactId").text();
	            Element versionElement = dependency.selectFirst("version");

	            if (versionElement != null) {
	                String currentVersion = versionElement.text();
	                
	                // Ottieni la versione più recente per il groupId e artifactId corrente
	                String latestVersion = getLatestVersion(groupId, artifactId, latestVersions);

	                if (latestVersion != null && !latestVersion.equals(currentVersion)) {
	                    if (currentVersion.startsWith("${") && currentVersion.endsWith("}")) {
	                        // Caso in cui la versione è centralizzata in <properties>
	                        String propertyName = currentVersion.substring(2, currentVersion.length() - 1);
	                        updatePropertyVersion(doc, propertyName, latestVersion);
	                    } else {
	                        // Aggiorna la versione direttamente
	                        versionElement.text(latestVersion);
	                        System.out.println("Updated " + groupId + ":" + artifactId + " from version " + currentVersion + " to " + latestVersion);
	                    }
	                }
	            }
	        }

	        // Salva le modifiche nel file pom.xml
	        saveDocumentToFile(doc, pomFile);

	    } catch (Exception e) {
	        System.err.println("Error processing file: " + pomFile.getAbsolutePath());
	        e.printStackTrace();
	    }
	}





	private String getLatestVersion(String groupId, String artifactId, List<ProjectVersions> latestVersions) {
		for (ProjectVersions version : latestVersions) {
			if (version.getGroupId().equals(groupId) && version.getArtifactId().equals(artifactId)) {
				return version.getVersion();
			}
		}
		return null;
	}

	private void saveDocumentToFile(Document doc, File file) {
		try {
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			Transformer transformer = transformerFactory.newTransformer();
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(file);
			transformer.transform(source, result);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Override
	public void updateAllPomFiles(String startDir) {
		// Find each file pom.xml in starting directory
		List<File> pomFiles = findAllPomFiles(startDir);

		// Get local versions for the existing dependencies
		List<ProjectVersions> latestVersions = getLocalVersions(pomFiles);

		// Update each file pom.xml with most recent local versions
		for (File pomFile : pomFiles) {
			System.out.println("Updating " + pomFile.getAbsolutePath());
			updatePomFile(pomFile, latestVersions);
		}

		System.out.println("All pom.xml files have been updated. ");
	}

	private void updatePropertyVersion(Document doc, String propertyName, String newVersion) {
		NodeList propertiesNodes = doc.getElementsByTagName("properties");

		// Ensure <properties> exists
		if (propertiesNodes.getLength() > 0) {
			Element propertiesElement = (Element) propertiesNodes.item(0);
			NodeList propertyNodeList = propertiesElement.getElementsByTagName(propertyName);

			if (propertyNodeList.getLength() > 0) {
				Node propertyNode = propertyNodeList.item(0);
				System.out.println("Updating property " + propertyName + " to version " + newVersion);
				propertyNode.setTextContent(newVersion);
			} else {
				System.out.println("Property " + propertyName + " not found in <properties>.");
			}
		}
	}
}
